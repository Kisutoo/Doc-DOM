<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <div class="scores">HighScore</div>
    <div class="chrono"></div>
</header>
    <div id="board"></div>

    <script>
        
        let temps = 0;
        let timerElement = document.querySelector(".chrono")
        timerElement.innerText = temps

        let participant = "";

        // Fontion qui fait office de chronomètre
        function chrono()
        {
            let minutes = parseInt(temps / 60, 10);
            let secondes = parseInt(temps % 60, 10)

            minutes = minutes < 10 ? "0" + minutes : minutes;
            secondes = secondes < 10 ? "0" + secondes : secondes

            timerElement.innerText = `${minutes} : ${secondes}`;
            temps++;
        }

        let chronoFonction = setInterval(chrono, 1000)

        // Fonction qui sert à mélanger les boite dans le but de compléxifier le jeu
        function shuffleChildren(parent)
        {
            let children = parent.children // Children équivaut aux box si l'on suit le chemin de board --> box
            let i = children.length, k, temp // i vaut le nombre de boites et assignation de k et temp
            while(--i > 0){  // On boucle tant que 1 oté de i est toujours positif
                // k stocke un nombre aléatoire basé sur i
                k = Math.floor(Math.random() * (i+1)) // temp pointe temporairement l'élément à la position k dans board
                temp = children[k] // remplace l'élément à la position k par l'élément à la position i
                children[k] = children[i] // place l'élément k pointé temporairement à la fin du contenu de board
                parent.appendChild(temp) // On renvoie la box dans board
            }
        }

        function showReaction(type, clickedBox)
        {
            clickedBox.classList.add(type)
            if(type !== "success"){
                setTimeout(function(){ // Sert à retarder l'appel de la fonction
                    clickedBox.classList.remove(type)
                }, 800);
            }
        }

        const box = document.createElement("div"); // créé un élément div et l'assigne à la variable box
        box.classList.add("box"); // Donne un nom de class à l'élément souhaité

        const board = document.querySelector("#board"); // Assigne à la variable board, la div id board
        
        let nb = 1;
        let cb = prompt("Veuillez indiquez le nombre de boites");
        let storeScore = []
        storeScore.push(JSON.parse(localStorage.getItem(`highScore : ${cb} box`)));
        localStorage.setItem(`highScore : ${cb} box`, JSON.stringify(storeScore));


        function gameBox(storeScore){
            for(let i = 1; i <= cb; i++){  // Boucle for de 1 à nb box
                let newBox = box.cloneNode() // On clone la box du dessus pour l'assigner à newBox. Le fait d'utiliser cloneNode sert à ne pas écraser l'ancienne variable à chaque tour de boucle
                newBox.innerText = i; // On inscrit du texte dans la boite en l'occurence, i qui va s'incrément au fur et à mesure que les box se créent
                board.appendChild(newBox); // Place un élément du DOM à la fin du contenu de l'élément visé / prepend pour l'ajouter au début
                newBox.addEventListener("click", function(){ // Lorsque l'on clique sur newBox, il y a un appel de fonction
                
                if(i == nb){ // si i est égal à nb
                    shuffleChildren(board);
                    newBox.classList.add("box-clicked"); // Ajoute la class "box-clicked" à la box nouvellement crée
                    if(nb == board.children.length){ // Si on a cliqué sur toutes les box dans le bon ordre (jeu fini)
                            let a = [];
                            board.querySelectorAll(".box").forEach(function(box){ // Toutes les box deviennent vertes
                                showReaction("success", box);
                            })
                            clearInterval(chronoFonction); // Arrêt du chrono
                            a = JSON.parse(localStorage.getItem(`highScore : ${cb} box`)) || [];
                            participant = prompt("Quel est votre pseudo de gagnant ?");   // On enregistre le score dans le local storage
                            a.push(`-  ${participant} : ${timerElement.innerText} secondes\n`);
                            localStorage.setItem(`highScore : ${cb} box`, JSON.stringify(a));
                    }
                    nb++ // Incrémentation de nb
                }
                else if(i > nb){ // Si on clique sur une mauvaise box
                    showReaction("error", newBox)
                    nb = 1 // Si le numéro de la boite est supérieur à nb, c'est que le joueur a cliqué une boite trop élévée -> game over !
                    board.querySelectorAll(".box-clicked").forEach(function(validBox){ // Séléctionne toutes les box possédant le style box-valid puis effectue une boucle appliquant la fonction du dessous
                        validBox.classList.remove("box-clicked") // Cela retire la class valide box, ce qui retire le style inhérent à cette class
                    shuffleChildren(board);
                    })
                }
                else{
                    showReaction("notice", newBox) // Dernière possibilité : Le joueur a cliqué sur une boite déjà grisée. On l'informe simplement de cela, le jeu ne redémarre pas.
                    }
                })
            }
        }
        
        const scores = document.querySelector(".scores") /// A FAIRE : récupérer ce qu'il y a dans le local storage le mettre sous force de variable dans un tableau puis l'afficher avec alert
        
        
        gameBox(storeScore);
        shuffleChildren(board)
        scores.addEventListener('click', function(){
                alert(storeScore)
        })
    </script>
</body>
</html>